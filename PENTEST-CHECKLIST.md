# ComplyEur v2 — Penetration Testing Checklist

**Application:** ComplyEur (B2B SaaS — EU 90/180-day Schengen visa compliance tracker)
**Stack:** Next.js (App Router) + Supabase (PostgreSQL, Auth, Edge Functions) + Stripe + Vercel
**Date prepared:** 2026-02-19

---

## 1. Authentication & Session Management

### 1.1 Email/Password Authentication
- [ ] Brute-force login attempts — verify rate limiting kicks in (configured: 10 req/min per IP)
- [ ] User enumeration via login error messages — confirm identical responses for invalid email vs wrong password
- [ ] User enumeration via signup — confirm identical responses for existing vs new email
- [ ] User enumeration via forgot-password — confirm success response regardless of email existence
- [ ] Password complexity enforcement — test minimum length and character requirements (Supabase-managed)
- [ ] Account lockout mechanism — test whether repeated failures lock the account or just rate-limit
- [ ] Session fixation — confirm session token is rotated after login
- [ ] Session expiry — confirm JWT tokens expire and are refreshed correctly
- [ ] Concurrent session handling — log in from multiple devices, verify session isolation
- [ ] Logout completeness — confirm session is fully invalidated server-side on logout
- [ ] Password reset token expiry — confirm tokens expire (~1 hour expected)
- [ ] Password reset token reuse — confirm tokens are single-use
- [ ] Password reset rate limiting — verify stricter limit (configured: 5 req/hour per IP)

### 1.2 OAuth (Google)
- [ ] OAuth account linking attack — register email/password, then try to log in via Google with same email (should be blocked by `auth-hook-prevent-linking` edge function)
- [ ] OAuth state parameter validation — confirm CSRF protection on OAuth callback
- [ ] OAuth callback open redirect — test `/auth/callback?next=//evil.com` and other bypass patterns
- [ ] OAuth scope verification — confirm only minimal scopes are requested
- [ ] OAuth token storage — confirm tokens are stored securely (httpOnly cookies, not localStorage)
- [ ] Company name inference via email domain — test if attacker can claim a company name by registering with a specific domain email

### 1.3 Multi-Factor Authentication (MFA)
- [ ] MFA bypass — attempt to access protected routes without completing MFA challenge
- [ ] MFA enrollment manipulation — test if user can unenroll MFA to bypass enforcement
- [ ] MFA code brute-force — test rate limiting on TOTP verification attempts
- [ ] MFA recovery flow — test backup code usage and rate limits
- [ ] MFA enforcement scope — currently only enforced for hardcoded admin emails; verify non-admin users can't access admin features without MFA

---

## 2. Authorization & Access Control

### 2.1 Role-Based Access Control (RBAC)
Roles: Owner > Admin > Manager > Viewer

- [ ] Vertical privilege escalation — Viewer attempts to create/update/delete employees (should fail)
- [ ] Vertical privilege escalation — Manager attempts to delete employees (should fail, only Owner/Admin)
- [ ] Vertical privilege escalation — Manager attempts to manage team members/invites (should fail)
- [ ] Vertical privilege escalation — Manager/Viewer attempts to modify company settings (should fail)
- [ ] Vertical privilege escalation — Non-owner attempts GDPR actions (DSAR export, anonymize, delete)
- [ ] Role self-elevation — user modifies their own role via API manipulation
- [ ] Role manipulation via team invite — accept invite and tamper with role assignment
- [ ] Permission check consistency — verify every server action enforces `enforceMutationAccess()` (not just UI hiding)
- [ ] Direct API call without UI — call server actions directly bypassing client-side permission checks

### 2.2 Multi-Tenant Isolation
- [ ] Cross-tenant data read — user from Company A attempts to read Company B's employees
- [ ] Cross-tenant data write — user from Company A attempts to modify Company B's trips
- [ ] Cross-tenant data delete — user from Company A attempts to delete Company B's employee
- [ ] Cross-tenant DSAR export — request `/api/gdpr/dsar/[company-B-employee-id]`
- [ ] Cross-tenant trip access — attempt to view/edit trips belonging to another company's employee
- [ ] Cross-tenant calendar/dashboard — verify dashboard only shows own company's data
- [ ] Cross-tenant export — verify CSV/PDF exports only contain own company's data
- [ ] RLS policy bypass — test if any Supabase queries use service role key unnecessarily
- [ ] RLS policy completeness — verify all tables have RLS enabled (auto-enforced by `rls_auto_enable()` trigger)
- [ ] Direct database query via Supabase REST API — attempt raw PostgREST queries with anon key to bypass application-level checks

### 2.3 Admin Panel
- [ ] Admin panel discovery — access `/admin` as non-admin user (should silently redirect)
- [ ] Admin panel access with non-allowlisted email — verify 403/redirect
- [ ] Admin panel access without MFA — verify MFA is enforced for admin-level actions
- [ ] Superadmin flag manipulation — attempt to set `is_superadmin=true` via Supabase REST API
- [ ] Admin entitlement tampering — attempt to update another company's tier/limits
- [ ] Admin audit log integrity — verify all admin actions are logged with before/after state, IP, user agent
- [ ] Admin audit log deletion — verify logs cannot be deleted/modified (INSERT-only table)
- [ ] Admin trial extension abuse — extend trial to unreasonable date
- [ ] Admin company suspension bypass — suspended company user attempts to access application

---

## 3. Input Validation & Injection

### 3.1 SQL Injection
- [ ] Employee name field — `'; DROP TABLE employees; --`
- [ ] Company name field — `' OR '1'='1`
- [ ] Trip country field — test against 2-char ISO code CHECK constraint
- [ ] Search/filter parameters — inject SQL via query parameters
- [ ] Import CSV employee names — SQL payloads in imported data
- [ ] Supabase RPC parameters — test `create_company_and_profile()` with malicious inputs
- [ ] Supabase PostgREST filter parameters — test `.eq()`, `.like()`, `.in()` with injection payloads

### 3.2 Cross-Site Scripting (XSS)
- [ ] Stored XSS via employee name — `<script>alert('xss')</script>`
- [ ] Stored XSS via company name — `<img src=x onerror="alert('xss')">`
- [ ] Stored XSS via trip notes/comments — if any free-text fields exist
- [ ] Stored XSS via CSV import — import file with XSS payloads in all columns
- [ ] Reflected XSS via URL parameters — test all query parameters in dashboard routes
- [ ] Reflected XSS via error messages — test if error messages echo user input unsanitized
- [ ] DOM XSS via redirect parameter — test `redirectTo` parameter in auth flows
- [ ] CSP bypass — current policy includes `'unsafe-inline'` for scripts, test if inline XSS executes

### 3.3 CSV/Formula Injection
- [ ] CSV injection via employee name — `=cmd|'/C calc'!A0`
- [ ] CSV injection via export — verify `sanitizeCsvValue()` escapes formula characters (`=`, `+`, `-`, `@`, `\t`, `\r`)
- [ ] CSV injection via import → export cycle — import data with formula chars, then export and open in Excel
- [ ] Tab/newline injection in CSV fields — test if exported CSV can break cell boundaries

### 3.4 Server-Side Request Forgery (SSRF)
- [ ] OAuth redirect URL manipulation — test if callback URL can be redirected to internal services
- [ ] Stripe webhook URL — verify webhook endpoint doesn't follow redirects
- [ ] Supabase connection strings — verify no user-controlled database connection parameters

### 3.5 Open Redirect
- [ ] Login redirect — `/login?redirectTo=//evil.com`
- [ ] Login redirect — `/login?redirectTo=/\evil.com`
- [ ] Login redirect — `/login?redirectTo=javascript:alert(1)`
- [ ] OAuth redirect — `signInWithGoogle(redirectTo: '//evil.com')`
- [ ] Post-signup redirect — verify redirect after account creation
- [ ] Stripe checkout return URL — verify `success_url` and `cancel_url` are hardcoded

---

## 4. API Security

### 4.1 Rate Limiting
- [ ] API route rate limit — exceed 60 req/min to any `/api/*` endpoint
- [ ] Auth rate limit — exceed 10 req/min on login/signup
- [ ] Password reset rate limit — exceed 5 req/hour
- [ ] Rate limit bypass via `X-Forwarded-For` header spoofing
- [ ] Rate limit bypass via IPv6 rotation
- [ ] Rate limit bypass via `X-Real-IP` header manipulation
- [ ] Rate limit headers disclosure — verify `X-RateLimit-Remaining` doesn't leak sensitive info
- [ ] Distributed brute-force — same account, different IPs (per-IP limits don't protect against this)
- [ ] Server action rate limiting — verify rate limits on all mutation server actions
- [ ] Promotion code enumeration — rapid attempts on `/api/billing/checkout` with different codes

### 4.2 API Endpoint Security
- [ ] HTTP method tampering — send GET to POST-only endpoints and vice versa
- [ ] Content-Type manipulation — send `text/plain` instead of `application/json`
- [ ] Request body size limit — send >1MB payload to middleware (should return 413)
- [ ] Request body size vs upload limit mismatch — middleware blocks 1MB but imports allow 5MB files
- [ ] Missing authentication — call all API routes without session cookie
- [ ] Expired token access — use expired JWT to access protected routes
- [ ] API response information leakage — verify error responses don't expose stack traces or internal paths

### 4.3 CORS & CSRF
- [ ] CORS configuration — verify `Access-Control-Allow-Origin` is restrictive
- [ ] CSRF on state-changing endpoints — POST to `/api/billing/checkout` from external origin
- [ ] CSRF on server actions — invoke Next.js server actions from external origin
- [ ] Preflight request handling — verify OPTIONS requests are handled correctly

---

## 5. Stripe & Billing Security

### 5.1 Webhook Security
- [ ] Webhook signature bypass — send webhook without valid Stripe HMAC signature
- [ ] Webhook replay attack — capture and replay a valid webhook event (should be deduplicated via `stripe_webhook_events` idempotency)
- [ ] Webhook event type spoofing — send `checkout.session.completed` with arbitrary metadata
- [ ] Subscription tier escalation — manipulate `metadata.plan_slug` in webhook payload (signature should prevent this)
- [ ] Webhook timing attack — send events out of order (e.g., `subscription.deleted` before `checkout.completed`)
- [ ] Webhook secret exposure — check if `STRIPE_WEBHOOK_SECRET` appears in logs or error responses

### 5.2 Checkout Flow
- [ ] Plan slug manipulation — submit invalid plan slug to `/api/billing/checkout`
- [ ] Price ID tampering — verify price ID comes from database, not user input
- [ ] Billing interval manipulation — submit invalid interval (not 'monthly' or 'annual')
- [ ] Promotion code abuse — test valid codes from other campaigns
- [ ] Client reference ID spoofing — verify `client_reference_id` is set server-side from session
- [ ] Checkout session hijacking — capture checkout URL, use in different browser/account
- [ ] Billing portal IDOR — access Stripe billing portal for another company
- [ ] Free tier entitlements — verify free users can't access paid features
- [ ] Subscription downgrade handling — verify entitlements are revoked immediately on downgrade
- [ ] Trial extension abuse — verify trial can't be extended by user manipulation

---

## 6. File Upload & Import

### 6.1 File Upload Validation
- [ ] File type bypass — upload `.exe` renamed to `.csv`
- [ ] File type bypass — upload with manipulated MIME type header
- [ ] Double extension — upload `malware.csv.exe`
- [ ] MIME type vs extension mismatch — valid extension, wrong MIME type
- [ ] Null byte injection — `file.csv%00.exe`
- [ ] Oversized file — upload file exceeding 5MB limit
- [ ] Empty file — upload 0-byte file
- [ ] File with no extension — upload file without extension

### 6.2 Content-Based Attacks
- [ ] XLSX bomb — upload XLSX with billions of cells (memory exhaustion)
- [ ] XLSX XXE — upload XLSX with external entity references in XML internals
- [ ] XLSX with macros — upload `.xlsm` with VBA macros
- [ ] CSV with excessive columns — test parser handling of unexpected column count
- [ ] CSV with excessive rows — test memory limits with millions of rows
- [ ] CSV encoding attacks — upload with unusual encodings (UTF-16, UTF-7)
- [ ] CSV with embedded nulls — test parser handling of null bytes in data
- [ ] Polyglot file — file that is valid as both XLSX and HTML

### 6.3 Import Logic
- [ ] Import race condition — two concurrent imports creating duplicate employees
- [ ] Import with cross-tenant employee IDs — verify imported data is scoped to current company
- [ ] Import column mapping manipulation — tamper with mapping configuration
- [ ] Import validation bypass — submit import with invalid data types (non-date in date field)

---

## 7. GDPR & Data Protection

### 7.1 DSAR (Data Subject Access Request) Export
- [ ] IDOR on DSAR export — request export for employee belonging to another company
- [ ] Unauthorized DSAR — Manager/Viewer role attempts DSAR export (Owner/Admin only)
- [ ] DSAR signed URL prediction — attempt to guess or enumerate signed URLs
- [ ] DSAR signed URL expiry — access URL after 1-hour expiry window
- [ ] DSAR data completeness — verify export contains all personal data (GDPR Article 15 compliance)
- [ ] Concurrent DSAR requests — multiple simultaneous requests for same employee

### 7.2 Data Deletion & Anonymization
- [ ] Unauthorized deletion — non-Owner/Admin attempts GDPR deletion
- [ ] Unauthorized anonymization — non-Owner/Admin attempts employee anonymization
- [ ] Anonymization reversibility — verify anonymized data cannot be recovered
- [ ] Soft-delete recovery window — verify 30-day recovery window, then hard delete
- [ ] Delete then re-create — delete employee, create new one with same details (data leakage check)
- [ ] CRON retention job authentication — call `/api/gdpr/cron/retention` without valid `CRON_SECRET`
- [ ] CRON retention job with invalid token — test with expired or malformed bearer token
- [ ] CRON retention job trigger timing — verify job can't be triggered to prematurely delete data

### 7.3 Audit Logging
- [ ] GDPR audit log completeness — verify all GDPR actions (export, delete, anonymize, restore) are logged
- [ ] Audit log access control — verify only Owner/Admin can view GDPR audit log
- [ ] Audit log tampering — verify logs are immutable (no UPDATE/DELETE permissions)

---

## 8. Security Headers & Transport

### 8.1 HTTP Headers
- [ ] Content-Security-Policy — currently allows `'unsafe-inline'` for scripts (weakness)
- [ ] X-Frame-Options — verify `DENY` or `SAMEORIGIN` is set (clickjacking protection)
- [ ] X-Content-Type-Options — verify `nosniff` is set (MIME sniffing protection)
- [ ] Strict-Transport-Security — verify HSTS header with reasonable `max-age`
- [ ] Referrer-Policy — verify sensitive URLs aren't leaked via Referer header
- [ ] Permissions-Policy — verify unnecessary browser features (camera, microphone, geolocation) are restricted
- [ ] Cache-Control on sensitive endpoints — verify `no-store` on auth and GDPR endpoints
- [ ] X-Powered-By — verify framework version isn't disclosed

### 8.2 TLS & Transport
- [ ] TLS version — verify TLS 1.2+ only (Vercel-managed)
- [ ] Certificate validity — verify SSL certificate is valid and not self-signed
- [ ] Mixed content — verify no HTTP resources loaded on HTTPS pages
- [ ] Cookie flags — verify `Secure`, `HttpOnly`, `SameSite` on session cookies

---

## 9. Business Logic

### 9.1 90/180-Day Compliance Calculations
- [ ] Date manipulation — create overlapping trips to confuse day counting
- [ ] Timezone exploitation — submit trips with dates that shift across midnight in different timezones (should use `date-fns parseISO`, not native `Date`)
- [ ] Boundary testing — trips exactly at 90 days, 180-day window boundaries
- [ ] Negative day trips — `exit_date` before `entry_date`
- [ ] Zero-day trips — same `entry_date` and `exit_date`
- [ ] Future trip handling — trips far in the future
- [ ] Retroactive trip modification — modify old trips that affect current compliance status

### 9.2 Seat Limits & Entitlements
- [ ] Exceed employee limit — create more employees than tier allows
- [ ] Exceed user/seat limit — invite more team members than tier allows
- [ ] Feature access beyond tier — access paid features (forecasting, exports, alerts) on free tier
- [ ] Tier caching — downgrade tier but continue accessing premium features via cached entitlements
- [ ] Concurrent seat usage — race condition on seat creation near limit

### 9.3 Onboarding
- [ ] Onboarding bypass — navigate directly to `/dashboard` without completing onboarding
- [ ] Onboarding replay — complete onboarding, then revisit `/onboarding`
- [ ] Onboarding data manipulation — submit invalid data during onboarding flow

---

## 10. Infrastructure & Configuration

### 10.1 Environment & Secrets
- [ ] Environment variable exposure — check if `.env`, `.env.local`, `.env.production` are accessible via HTTP
- [ ] Source map exposure — check if JavaScript source maps are served in production
- [ ] Git directory exposure — check if `/.git/` is accessible
- [ ] Supabase service role key exposure — verify `SUPABASE_SERVICE_ROLE_KEY` never appears in client bundles
- [ ] Stripe secret key exposure — verify `STRIPE_SECRET_KEY` never appears in client bundles
- [ ] Error stack trace leakage — trigger errors and check for internal path disclosure
- [ ] Debug mode — verify no debug endpoints or flags are enabled in production

### 10.2 Supabase-Specific
- [ ] Supabase REST API direct access — query PostgREST endpoints directly with anon key
- [ ] Supabase Auth admin endpoints — verify admin auth endpoints are restricted
- [ ] Supabase Storage bucket permissions — verify `gdpr-exports` bucket is private
- [ ] Supabase Edge Function bypass — verify edge functions can't be disabled or circumvented
- [ ] Supabase realtime subscriptions — verify RLS applies to realtime listeners (if used)
- [ ] Database connection string exposure — verify connection strings aren't in client code

### 10.3 Vercel-Specific
- [ ] Vercel deployment URL exposure — check if preview deployment URLs are guessable
- [ ] Vercel serverless function timeout — test long-running requests (e.g., large imports)
- [ ] Vercel edge middleware bypass — test if middleware can be bypassed via direct function invocation
- [ ] `_next/data` endpoint access — verify server-side data fetching endpoints enforce auth

---

## 11. Denial of Service (Application-Level)

- [ ] Login flood — mass login attempts to exhaust rate limiter storage
- [ ] Signup flood — mass account creation
- [ ] Password reset flood — mass password reset requests to flood email
- [ ] Import flood — mass file upload requests
- [ ] DSAR export flood — mass GDPR export requests (ZIP generation is CPU-intensive)
- [ ] Large payload — submit extremely large JSON bodies to server actions
- [ ] Regex DoS (ReDoS) — test input validation regexes with catastrophic backtracking payloads
- [ ] Webhook flood — if attacker discovers webhook endpoint, test with high volume (signature validation cost)

---

## 12. Compliance-Specific Risks

- [ ] Data residency — verify data is stored in declared regions (London for prod, Frankfurt for staging)
- [ ] Data retention — verify data is deleted according to retention policy (30-day soft-delete window)
- [ ] Right to erasure — verify GDPR deletion actually removes data (not just soft-delete)
- [ ] Consent management — verify appropriate consent is obtained for data processing
- [ ] Data breach notification — verify logging and monitoring infrastructure exists
- [ ] Cross-border data transfer — verify no data transferred outside declared regions
- [ ] Subprocessor chain — audit third-party data processors (Supabase, Stripe, Vercel, Upstash)

---

## Key Files for Testing Reference

| Area | File Path |
|------|-----------|
| Middleware (rate limiting, auth routing) | `middleware.ts` |
| Auth actions (login, signup, OAuth) | `app/(auth)/actions.ts` |
| OAuth callback handler | `app/auth/callback/route.ts` |
| Dashboard mutations (CRUD + permissions) | `app/(dashboard)/actions.ts` |
| Import/upload actions | `app/(dashboard)/import/actions.ts` |
| GDPR actions | `app/(dashboard)/gdpr/actions.ts` |
| GDPR DSAR API endpoint | `app/api/gdpr/dsar/[employeeId]/route.ts` |
| GDPR retention CRON | `app/api/gdpr/cron/retention/route.ts` |
| Stripe webhook handler | `app/api/billing/webhook/route.ts` |
| Stripe checkout | `app/api/billing/checkout/route.ts` |
| Stripe billing portal | `app/api/billing/portal/route.ts` |
| Admin panel actions | `app/admin/companies/[id]/actions.ts` |
| Admin auth (email allowlist) | `lib/admin/auth.ts` |
| RBAC permissions | `lib/permissions.ts` |
| Rate limiting | `lib/rate-limit.ts` |
| Tenant access control | `lib/security/tenant-access.ts` |
| MFA enforcement | `lib/security/mfa.ts` |
| CRON auth | `lib/security/cron-auth.ts` |
| Authorization guards | `lib/security/authorization.ts` |
| CSV sanitization | `lib/exports/sanitize.ts` |
| Redirect validation | `lib/utils/redirect.ts` |
| Supabase admin client (RLS bypass) | `lib/supabase/admin.ts` |
| OAuth linking prevention hook | `supabase/functions/auth-hook-prevent-linking/index.ts` |
| Team management actions | `app/(dashboard)/settings/team/actions.ts` |
| Onboarding actions | `app/(onboarding)/onboarding/actions.ts` |

---

## Notes for the Tester

1. **Multi-tenant architecture** — the most critical attack vector is cross-company data access. Every query is scoped by `company_id` via Supabase Row-Level Security, but application-layer checks must also be verified.

2. **Admin panel** — access is gated by a hardcoded email allowlist and `is_superadmin` database flag. This is a high-value target.

3. **CSP weakness** — the current Content-Security-Policy includes `'unsafe-inline'` for scripts, which significantly weakens XSS protection.

4. **Rate limiting** — IP-based via Upstash Redis. In production, the `X-Forwarded-For` header is trusted from Vercel's proxy. Test whether header spoofing is possible.

5. **File imports** — middleware enforces a 1MB body size limit, but file uploads allow up to 5MB. This mismatch may cause issues with legitimate large imports and should be tested.

6. **Supabase anon key** — publicly visible by design. All security depends on RLS policies being correctly configured on every table.
